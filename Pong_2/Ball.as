package  {	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.display.MovieClip;		public class Ball extends MovieClip {		private var bouncy:int;		public var vec:Point;		private var speed:int;		public var inCollision:Boolean = false;		public function Ball(x:int, y:int, speed:int, bouncy:int=1):void {			// constructor code			this.bouncy = bouncy;			this.speed= speed;			this.x = x;			this.y = y;			this.vec = new Point();					}		public function init():void {						this.stage.addEventListener(Event.ENTER_FRAME, checkLoop);		}		public function changeVector(v:Point):void {			this.vec = v;		}		private function checkLoop(e:Event):void {			// check collision			trace(this.vec);			checkCollision();			moveBall();		}				private function moveBall():void {			if (!this.inCollision) {				this.x += this.vec.x * this.speed;				this.y += this.vec.y * this.speed;			}		}				public function get nextPosition():Point {			return new Point(this.x + this.vec.x * this.speed, this.y + this.vec.y * this.speed);		}				private function checkCollision():void {			if (this.y - this.height/2.0 <= 0 ) {				// ball is at the top of the stage								// bounce				this.bounce(this.vec, new Point(0,1));							} else if (this.y + this.height/2.0 >= this.stage.stageHeight) {				// ball is at the bottom of the stage								// bounce				this.bounce(this.vec, new Point(0,-1));			}											}				// the Normal is the direction in which the surface is facing		public function bounce(v:Point, n:Point):void {			// R = V - 2 * (V · N)     			var d:Number = dot(v,n); 			var new_vec:Point =  new Point((v.x - 2 * d * n.x), (v.y - 2 * d * n.y));			this.vec = new_vec;			this.inCollision = false;		}				private function dot(v1:Point,v2:Point):Number {			return (v1.x*v2.x) + (v1.y*v2.y);		}			}	}